---
description: "NetBox integration patterns - Diode, pynetbox, webhooks, change tracking"
globs: ["**/*.py"]
alwaysApply: false
---

# NetBox Integration Best Practices

## Use Diode for Simplified Ingestion (HIGH)

For data ingestion, use [Diode](https://github.com/netboxlabs/diode) instead of direct REST API.

**Benefits:**
- Automatic dependency resolution (no need to create objects in order)
- Reference objects by name, not ID
- Single gRPC call for batch operations
- Built-in error handling

```python
from netboxlabs.diode.sdk import DiodeClient
from netboxlabs.diode.sdk.ingester import Device, Entity

with DiodeClient(
    target="https://<your-diode-host>:443/diode",
    app_name="network-discovery",
    app_version="1.0.0",
) as client:
    device = Device(
        name="switch-nyc-01",
        device_type="Cisco Catalyst 9300",  # By name!
        manufacturer="Cisco",                # Auto-created if missing
        site="NYC-DC1",                      # Auto-created if missing
        role="Access Switch",
        status="active",
    )
    response = client.ingest([Entity(device=device)])
```

Use `DiodeDryRunClient` to test ingestion without sending to server.

## Use pynetbox for Python Integrations (HIGH)

```python
import pynetbox

nb = pynetbox.api("https://netbox.example.com", token=TOKEN)

# Automatic pagination
all_devices = nb.dcim.devices.all()

# Filtering
active_devices = nb.dcim.devices.filter(status="active", site="nyc")

# Create
new_device = nb.dcim.devices.create(name="switch-01", ...)

# Update
device = nb.dcim.devices.get(name="switch-01")
device.status = "active"
device.save()
```

## Webhook Configuration

Configure webhooks for event-driven integrations:

```python
# Webhook payload structure
{
    "event": "created",
    "timestamp": "2024-01-15T10:30:00Z",
    "model": "dcim.device",
    "username": "admin",
    "request_id": "abc123",
    "data": { ... },       # Current state
    "snapshots": {
        "prechange": {},   # State before change
        "postchange": {}   # State after change
    }
}
```

**Best practices:**
- Use HTTPS endpoints
- Verify webhook signatures
- Process asynchronously (queue and acknowledge quickly)
- Handle idempotency (webhooks may be retried)

## When to Use What

| Scenario | Tool |
|----------|------|
| Network discovery pushing data | **Diode** |
| Bulk migrations | **Diode** |
| Python scripts/automation | **pynetbox** |
| Reading/querying data | REST/GraphQL |
| Single object CRUD | REST API |
| Event-driven updates | Webhooks |
| Complex filtered queries | REST/GraphQL |

## Change Tracking

Query object changes for audit trails:

```python
# Get changes for an object
response = requests.get(
    f"{API_URL}/extras/object-changes/",
    params={
        "changed_object_type": "dcim.device",
        "changed_object_id": device_id
    }
)
```

## NetBox Branching Plugin (HIGH)

> Requires [netbox-branching](https://github.com/netboxlabs/netbox-branching) plugin.

### Branch Workflow

```python
import requests
import time

# 1. Create branch
branch_resp = requests.post(
    f"{API_URL}/plugins/branching/branches/",
    headers=HEADERS,
    json={"name": "feature-update", "description": "Updates"}
)
branch = branch_resp.json()
schema_id = branch["schema_id"]  # 8-char ID for header

# 2. Wait for READY state
while True:
    b = requests.get(f"{API_URL}/plugins/branching/branches/{branch['id']}/", headers=HEADERS).json()
    if b["status"]["value"] == "ready":
        break
    time.sleep(2)

# 3. Work in branch context
branch_headers = {**HEADERS, "X-NetBox-Branch": schema_id}
requests.post(f"{API_URL}/dcim/devices/", headers=branch_headers, json={...})

# 4. Merge (async - returns Job)
merge_resp = requests.post(
    f"{API_URL}/plugins/branching/branches/{branch['id']}/merge/",
    headers=HEADERS,
    json={"commit": True}  # False for dry-run
)
job = merge_resp.json()

# 5. Poll job until complete
while True:
    j = requests.get(job["url"], headers=HEADERS).json()
    if j["status"]["value"] == "completed":
        break
    if j["status"]["value"] in ("errored", "failed"):
        raise RuntimeError(f"Merge failed: {j}")
    time.sleep(2)
```

### Key Points

- **Header**: `X-NetBox-Branch: {schema_id}` (8-char ID, not branch name)
- **States**: NEW → PROVISIONING → READY → MERGING → MERGED
- **Async ops**: sync/merge/revert return Jobs—always poll
- **Dry-run**: `{"commit": false}` validates without applying

## References

See `skills/netbox-integration-best-practices/references/rules/integ-*.md` for detailed rules.
